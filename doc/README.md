# Documentation

This page contains a brief architecture overview of the board and BCPU subprojects. The board design is written in the VHDL language and the brief architecture is in the following figure. The design is using two clock domains - (i) CLK A running on 12 MHz and (ii) CLK B for the user application (running on higher frequency). The CDC (Clock Domain Crossing). Clock modification (for the user application) is performed in the PLL block. Design is fully synchronized and therefore we need to solve the reset signals. All reset signals are held for several clock cycles to be sure that our design is in the initial state. The reset logic itself is solved via a series of registers to filter out the metastability.

The communication with user application is done via the UART component. The CDC (Clock Domain Crossing) for the user application is performed in UART SYNC component which also implements a communication protocol described in the [SW](../sw) section of this repository. The clock domain crossing itself is done via asynchronous FIFOs because we need to transfer signals of wider width. The LED signalization is a specialized block which transfers the internal activity to a LED signalization (e.g., RX/TX activity, design ready, BCPU enabled). Finally, the BCPU block is described in the Bluespec language, translated to Verilog and connected into the design. The details of this block are described in the next section of this documentation.

![board](figs/schema.png)

Bluespec is a Haskell based language used for the modelling of Digital Design circuits. The big advantage of this language is the possibility to describe the architecture and keep a high level of abstraction in the same time. The described BCPU core is a three-stage CPU - (i) instruction fetch, (ii) instruction decode & data preload and (iii) instruction execution & write-back. The design is KISS - no caches, no predictors for now - to demonstrate a simple design of Brainfuck CPU for an FPGA. Any advanced approaches are planned as (possible) future work. The design is using two Block Memories for a program (Instruction Memory) and data (Cell Memory). Cell data are write-back just in the case of cell memory pointer change (increment/decrement of pointed address). Work in progress data (for a given cell) are stored in the cell register - e.g, increments/decrements data input/output are performed on this register. The arbiter logic for the Instruction/Cell memory is used for the switching between BCPU and SW interface (accessed via the Read/Write Logic block) - design is using both ports of block memories. The Read/Write block contains all necessary logic for overall control of the BCPU core, upload/download of program, upload/download of cell memory, flag registers read, etc. This project also contains a communication library, compiler (for defined ISA), bbus tool (used for reading/writing from/to BCPU inside the FPGA) and programmer (more details are again in the [SW](../sw) subproject). Input/output data are stored in internal FIFO fronts and the BCPU is able of stalling in the case of data unavailability or output FIFO fulness. The Enable/Step functionality is controlled via a CMD register. This register is decoded to individual signals (for the BCore unit) in the CMD Decored block. The implementation of the BCPU block is in [bsv](../bsv) folder together with some Brainfuck examples in the [data test](../bsv/tests) folder.

![bcpu](figs/bcpu.png)